# Typescript learning
Работа в папке проекта из командной строки:
>tsc <filename.ts> // компиляция в js

>node <filename.js> // интерпретация
* при наличии файла конфигурации 'tsconfig.js':
>tsc -w (watch)


## TypeScript fundamentals (0_start)

* установка в систему TypeScript , конверсия .ts в .js (>tsc types)
* синтаксис ts указания типов данных, примитивных и не очень ( массивы)
* Tuple (кортеж - массив данных различного типа)
* тип 'any' === WTF (полный назад)
* функции обзорно - function(): void|never{}
* создание своих типов (Type)
* "интерфейсы" == свои типы данных для объектов| классов с определенными типами полей/ модификаторы (readonly),
приведение к типу
* наследование интерфейсов
* взаимодействие интерфейсов с классами ( зачем дублировать типы при расширении интерфейса и его имплементации в класс, если мы их не переопределяем? )
* ! type: Date вручную не создается...
* интерфейс для объекта с множеством динамических ключей (стили css)
* enums - структурирование кода с однотипными элементами
* функции (по-взрослому: перегрузка функции) здесь начинаю понимать, как тщательно нужно продумывать интерфейсы и сколько
 это требует доп времени :(
* классы
* модификаторы полей/методов классов (protected,public, private)
* абстрактные классы/методы (наследуются, но не компилируются)
* guards - вспомогательные конструкции для работы с типами (выбор обработчика внутри функции в зависимости от типа входных данных)
* generics (динамически подстраивающиеся типы данных)
* вспомогательные операторы (keyof, полиморфизм типа данных исключением (Exclude<keyof TypeName, 'fieldName'>),либо 
выбором (Pick<TypeName, 'fieldName'>) - мой термин :))

## Advanced TypeScript - some examples of use (1_advanced)

*установка пакетов 
*настройки компиляции .ts -> .js (>tsc --init => tsconfig.json{"exclude": ["./node_modules" // by default], 
"include": ["./.../**/*",], "files": ["./fileName.ext"]} + tsc --watch(-w) === замечательно!) 
* настройки конфигурации компилятора (compiler options: target | module | lib | sourceMap | removeComments | noEmitOnError | noImplicitAny | strictNullChecks |additionalChecks = стиль кода)
* '!' в конце выражения == гарантия разработчика компилятору, что значение != null ???(вместо проверок на наличие значения/элемента)
* generic types (позволяет использовать в качестве аргументов функций объекты с произвольными ключами и типами их значений,
ограничивая допустимый тип аргумента, а также наследовать конкретные поля таких объектов, заданные в интерфейсе, например, для 
контроля их наличия на этапе разработки)
* декораторы (в tsconfig раскомментировать experimentalDecorators: true для распознавания компилятором синтаксиса):
примеры логирующих декораторов/ пример добавления классу функционала: при создании инстанса размещать в DOM шаблон путем передачи
через декоратор дополнительных полей и операций.
* декоратор для привязки контекста инстанса к ссылке на его метод. (Вроде так)
* декоратор для валидации данных поля объекта класса
* namespaces
* дополнительные библиотеки (class-transformer)
